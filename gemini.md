# Lyric Stage - React × Hono 版

### TL;DR（1行）
Webカメラ × 歌詞同期 × 3Dステージで歌詞バブルに触れて遊ぶリズムインタラクティブゲーム；React + Hono 構成に完全移行、システムとデザインは一切変更なし。

### 短縮版
Lyric Stage は TextAlive で正確に同期した歌詞バブルを Three.js ステージ上に流し、マウス / 手 / 全身（MediaPipe）で“触れて”スコアを稼ぐゲーム。文字列正規化や表示ウィンドウ拡大で判定安定化。軽量 Hono サーバーを追加して静的配信 + API 拡張準備。視認性向上のため左上 viewer 歌詞はデフォルト無効化（プレイ用は保持）。

### 詳細ダイジェスト
- 核心価値: 触れる歌詞 + 身体インタラクション + ライブ演出で没入感。
- 入力モード: カーソル / ハンド（Hands） / ボディ（Pose）。背景は Selfie Segmentation で合成。
- 判定安定化: 文字列 NFC 正規化 / 500ms 表示判定 / DOM 紐付け強化。
- 表示整理: viewer 歌詞（左上）は `enableViewerLyrics=false` で無効化しノイズ削減。
- サーバー: Hono で静的配信 + `/api/health` `/api/echo`。将来スコア保存や認証に拡張余地。
- 将来案: スコア API / ランキング / JWT 認証 / Prisma / Edge デプロイ / 鑑賞モード再トグル。

### セクション案内
| 目的 | 該当セクション |
|------|----------------|
| セットアップ | セットアップと実行方法 |
| プレイ方法 | 遊び方 |
| ファイル構造把握 | プロジェクト構造 |
| 技術選定 | 使用技術 |
| コード改善点 | script.js の改善点 |
| サーバー概要 | Hono への移行 |
| 表示仕様変更 | 表示仕様更新（鑑賞/応援用テキストの無効化） |

---

## プロジェクト概要
このプロジェクト「Lyric Stage」は、音楽と同期して表示される歌詞にインタラクトすることでスコアを獲得する、革新的なリズムゲームです。単なるクリック操作に留まらず、ユーザーの身体の動きをゲームプレイに統合することで、没入感のある体験を提供します。

主要な特徴は以下の通りです。
-   **歌詞同期とインタラクション**: [TextAlive Player](https://textalive.jp/player/) を利用し、楽曲の再生に合わせて歌詞が正確なタイミングで表示されます。ユーザーは表示された歌詞に触れる（クリック、タップ、または身体の動き）ことでスコアを獲得し、コンボを繋げます。TextAlive APIが利用できない状況でも、簡易的なフォールバックモードで基本的なゲームプレイが可能です。
-   **3Dライブステージの表現**: [Three.js](https://threejs.org/) を用いて、ゲームの背景にダイナミックな3Dライブステージを構築しています。これにより、ゲームプレイに視覚的な奥行きと臨場感を与え、ユーザーを仮想のライブ空間へと誘います。
-   **カメラベースの多様なインタラクション**: [MediaPipe Pose](https://google.github.io/mediapipe/solutions/pose.html) と [MediaPipe Hands](https://google.github.io/mediapipe/solutions/hands.html) を活用し、Webカメラを通じたユーザーの身体の動きをゲーム入力として利用します。これにより、マウス操作だけでなく、ペンライトを振るような手の動きや、全身を使ったインタラクション（例: アバターの操作）でゲームをプレイできる、ユニークな体験を実現しています。

## セットアップと実行方法

### 1. ファイルの配置
本プロジェクトは、クライアントサイドのWebアプリケーションとして設計されています。そのため、以下のすべてのプロジェクトファイル（`game-loader.js`, `game.html`, `index-scripts.js`, `index-styles.css`, `index.html`, `script.js`, `styles.css`）を、Webサーバーの公開ディレクトリ（ドキュメントルート）または任意のサブディレクトリに配置する必要があります。これは、Webブラウザのセキュリティ制約（特にカメラアクセスやクロスオリジンリクエスト）により、ローカルファイルシステムから直接HTMLファイルを開く場合、一部の機能が正しく動作しないためです。

### 2. 依存関係
このプロジェクトは、外部のJavaScriptライブラリをCDN（Content Delivery Network）経由で動的に読み込むため、特別なインストール作業（例: `npm install`）は不要です。必要なライブラリは、`index.html` および `game.html` 内の`<script src="...">`タグによって自動的にロードされます。

-   **TextAlive Player**: 音楽の再生制御、歌詞のタイミング情報（単語、文字単位）の取得、および歌詞表示イベントのトリガーに使用されます。
    -   `https://unpkg.com/textalive-app-sdk/dist/textalive-app-sdk.min.js`
-   **Three.js**: ライブステージの3Dモデル（床、壁、ライト、ペンライト、アバターなど）の描画、カメラ制御、およびシーンのレンダリングに使用されます。
    -   `https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js`
-   **MediaPipe Pose**: Webカメラの映像からユーザーの全身の2D/3Dランドマーク（関節点）をリアルタイムで推定し、ボディモードでのインタラクション（例: アバターの動き、特定のポーズ検出）に利用されます。
    -   `https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js`
-   **MediaPipe Hands**: Webカメラの映像からユーザーの手の2D/3Dランドマーク（指の関節点）をリアルタイムで推定し、ハンドモードでのインタラクション（例: 指のタップ、手のひらの動き）に利用されます。
    -   `https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js`
-   **MediaPipe Selfie Segmentation**: Webカメラの映像から人物と背景をリアルタイムで分離し、ユーザーの姿だけを3Dステージに合成する（バーチャル背景）ために使用されます。
    -   `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js`

### 3. 実行
プロジェクトを完全に機能させるためには、ローカルHTTPサーバーを介して`index.html`にアクセスすることを強く推奨します。これにより、Webカメラへのアクセス許可が適切に処理され、MediaPipeなどの機能が制限なく利用できます。

#### ローカルHTTPサーバーの例:

**Node.js (http-server) の場合:**
`http-server`は、Node.js環境で利用できるシンプルで軽量なHTTPサーバーです。
```bash
# まず、http-serverをグローバルにインストールします（初回のみ実行）
npm install -g http-server
# プロジェクトのルートディレクトリ（index.htmlがある場所）に移動し、以下のコマンドを実行します。
http-server -p 8000
# サーバーが起動したら、Webブラウザで以下のURLにアクセスしてください。
# http://localhost:8000/index.html
```

**VS CodeのLive Server拡張機能:**
Visual Studio Codeを使用している開発者には、「Live Server」拡張機能の利用が非常に便利です。
1.  VS Codeの拡張機能ビューで「Live Server」を検索し、インストールします。
2.  `index.html`ファイルを右クリックし、コンテキストメニューから「Open with Live Server」を選択します。
3.  自動的にブラウザが開き、ローカルサーバー経由でゲームが起動します。

## 遊び方
「Lyric Stage」は、直感的でインタラクティブなゲームプレイを提供します。

1.  **ゲームの開始**: WebブラウザでローカルHTTPサーバー経由で`index.html`を開くと、ゲームのタイトル画面が表示されます。
2.  **プレイモードの選択**: 画面中央に表示されるボタンから、以下のいずれかのプレイモードを選択します。
    *   **カーソルモード**: マウスカーソルまたはタッチスクリーンデバイスでのタップ操作で、画面上の歌詞に触れます。最も基本的な操作モードです。
    *   **ハンドモード**: Webカメラに手を映し、指の動き（例: 人差し指でタップするような動き）を検出して歌詞に触れます。MediaPipe Handsが手のランドマークをリアルタイムで追跡し、ゲーム入力に変換します。
    *   **ボディモード**: Webカメラに全身を映し、体の動き（特に腕や手の動き）を検出して歌詞に触れます。MediaPipe Poseが全身のランドマークを追跡し、ゲーム内のアバターの動きと連動させたり、特定のジェスチャーをゲーム入力として認識します。
3.  **楽曲の選択とゲーム開始**: プレイモードを選択した後、利用可能な楽曲リストからプレイしたい曲を選択し、「プレイ」ボタンをクリックします。これにより、ゲーム画面（`game.html`）へ遷移します。
4.  **ゲームプレイ**:
    *   ゲーム画面で「再生」ボタンをクリックすると、選択した楽曲の再生が開始され、同時に歌詞が画面に流れてきます。
    *   **ボディモードの特別な注意**: ボディモードを選択した場合、ゲーム開始前にWebカメラに全身が映っていることを確認してください。全身が正常に検出されると、ゲーム開始までの5秒間のカウントダウンが始まります。ゲームプレイ中に全身が画面から3秒以上外れると、警告メッセージが表示され、ゲーム体験に影響が出る可能性があります。
    *   表示された歌詞の文字がインタラクション可能な範囲に入ったら、選択したモードに応じた方法（マウスでクリック、指でタップ、または体で触れる）でインタラクトします。
    *   歌詞を正確にヒットするとスコアが加算され、連続してヒットするとコンボが繋がります。コンボ数が多いほど、獲得スコアが増加します。
    *   **コンボのリセット**: 画面から消えるまでにヒットできなかった歌詞がある場合、現在のコンボはリセットされます。高スコアを目指すには、すべての歌詞をヒットし続けることが重要です。
5.  **リザルト画面**: 楽曲が終了すると、自動的にリザルト画面に移行します。ここでは、最終スコアと、それに応じたランク（例: S, A, Bなど）が表示され、ゲームプレイの成果を確認できます。

## プロジェクト構造
本プロジェクトは、機能ごとにファイルを分割し、保守性と拡張性を高めています。

-   `index.html`:
    *   **役割**: ゲームのランディングページであり、ユーザーが最初にアクセスするメインHTMLファイルです。
    *   **内容**: ゲームのタイトル表示、プレイモード選択ボタン（カーソル、ハンド、ボディ）、楽曲選択リスト、およびゲーム開始ボタンなどのUI要素が含まれます。また、`index-styles.css`と`index-scripts.js`を読み込みます。
-   `game.html`:
    *   **役割**: 実際のゲームプレイ画面を表示するためのHTMLファイルです。
    *   **内容**: ゲームのメインキャンバス（Three.jsのレンダリングターゲット）、歌詞表示エリア、スコア・コンボ表示、一時停止ボタンなどのゲームUI要素が含まれます。`styles.css`、`game-loader.js`、および`script.js`を読み込み、ゲームのロジックとビジュアルを統合します。
-   `script.js`:
    *   **役割**: ゲームの核となる主要なJavaScriptロジックを定義するファイルです。
    *   **内容**:
        *   **ゲーム状態管理**: スコア、コンボ、ゲーム進行状況などの状態を管理します。
        *   **歌詞の表示と判定**: TextAlive Playerから取得した歌詞データに基づき、歌詞バブルの生成、画面上での移動、ユーザーインタラクション（クリック、タップ、MediaPipeによる検出）の判定ロジックを実装します。
        *   **TextAlive Player連携**: 音楽の再生・一時停止、歌詞の同期表示、楽曲イベント（例: サビ、間奏）への応答などを制御します。
        *   **Three.jsによる3Dビジュアル**: ライブステージの構築（ジオメトリ、マテリアル、ライト）、ペンライトやアバターなどの3Dオブジェクトの配置とアニメーション、カメラの制御、およびレンダリングループを管理します。
        *   **MediaPipe連携**: MediaPipe Pose/Handsから取得したランドマークデータに基づき、ユーザーの動きをゲーム入力に変換するロジック（例: 手の座標から歌詞へのヒット判定、全身のポーズからアバターの動きを制御）を実装します。
        *   **プレイモードの切り替え**: 選択されたプレイモードに応じて、インタラクションの検出方法を切り替えるロジックが含まれます。
        *   **全身検出とカウントダウン**: ボディモードにおける全身検出の開始、カウントダウンタイマー、および検出失敗時の警告表示ロジック。
-   `game-loader.js`:
    *   **役割**: `game.html`がロードされた際に、ゲームの初期設定を行い、`script.js`で定義された`GameManager`クラスを初期化するためのスクリプトです。
    *   **内容**: `index.html`からURLパラメータとして渡されたプレイモードや選択された楽曲のIDなどの設定情報を取得し、これらを`GameManager`インスタンスに渡してゲームを開始します。
-   `styles.css`:
    *   **役割**: `game.html`で表示されるゲームプレイ画面全体の基本的なスタイリングを定義するCSSファイルです。
    *   **内容**: 歌詞バブルの見た目、スコア・コンボ表示のフォントや配置、ゲームUI要素（ボタンなど）のスタイル、および3Dキャンバスの基本レイアウトなどが含まれます。
-   `index-styles.css`:
    *   **役割**: `index.html`（タイトル画面）専用のスタイリングを定義するCSSファイルです。
    *   **内容**: タイトルロゴのフォントや配置、プレイモード選択ボタンや楽曲選択リストの見た目、背景画像やアニメーションなど、タイトル画面の視覚的なデザインを制御します。
-   `index-scripts.js`:
    *   **役割**: `index.html`（タイトル画面）のUIインタラクションと、ゲーム開始のためのロジックを定義するJavaScriptファイルです。
    *   **内容**:
        *   プレイモード選択ボタンのイベントハンドリング。
        *   楽曲選択リストの動的な生成と選択状態の管理。
        *   「プレイ」ボタンがクリックされた際に、選択されたプレイモードと楽曲情報をURLパラメータとして`game.html`に渡し、画面遷移を行うロジック。

## 使用技術
本プロジェクトは、最新のWeb技術と機械学習ライブラリを組み合わせて、リッチなインタラクティブ体験を実現しています。

-   **HTML5**:
    *   **用途**: ウェブページの構造とコンテンツを定義するためのマークアップ言語です。ゲームのUI要素（ボタン、テキスト表示領域）、`canvas`要素（Three.jsの3Dレンダリングターゲット、MediaPipeのカメラ映像表示）、`video`要素（Webカメラ映像の表示）などがHTMLで構成されます。
-   **CSS3**:
    *   **用途**: ウェブページのスタイリングとレイアウトを定義するためのスタイルシート言語です。ゲームの視覚的なデザイン（色、フォント、配置、アニメーション、レスポンシブデザイン）を制御し、ユーザーインターフェースの魅力を高めます。特に、歌詞バブルの動的なアニメーションや、3Dステージの背景スタイルなどに利用されます。
-   **JavaScript (ES6+)**:
    *   **用途**: ゲームのインタラクティブなロジック、動的なコンテンツ生成、イベント処理、外部ライブラリとの連携、およびゲームの状態管理を行うためのプログラミング言語です。プロジェクトの核となる部分であり、ゲームのすべての機能がJavaScriptで実装されています。
-   **TextAlive Player**:
    *   **用途**: 株式会社ドワンゴが提供する、音楽と歌詞を同期再生するためのJavaScriptライブラリです。本プロジェクトでは、TextAlive Playerから楽曲の再生状態、現在の歌詞（単語、文字）のタイミング情報、および歌詞の表示・非表示イベントを取得し、これに基づいてゲーム内で歌詞を正確に表示・制御します。これにより、ユーザーは音楽のリズムに合わせて歌詞にインタラクトできます。
-   **Three.js**:
    *   **用途**: ウェブブラウザ上で高性能な3Dグラフィックスを描画するためのJavaScriptライブラリです。ゲームのライブステージの背景（床、壁、照明）、ユーザーのアバター、ペンライトなどの3Dオブジェクトを構築し、リアルタイムでレンダリングするために利用されます。これにより、ゲームに視覚的な奥行きと没入感を与えます。
-   **MediaPipe Pose**:
    *   **用途**: Googleが提供する機械学習ソリューションで、Webカメラの映像からリアルタイムで全身のランドマーク（関節点）を推定します。本プロジェクトでは、ボディモードにおいてユーザーの全身の動きを検出し、ゲーム内のアバターを動かしたり、特定のポーズ（例: 手を挙げる）をゲーム入力として認識するために使用されます。CPU処理に最適化されており、比較的軽量に動作します。
-   **MediaPipe Hands**:
    *   **用途**: MediaPipeの一部で、Webカメラの映像から手のランドマーク（指の関節点）を推定します。ハンドモードにおいて、ユーザーの手の動き（例: 指を伸ばす、握る）を検出して歌詞へのインタラクション（例: 指でタップする）を可能にするために使用されます。これもCPU処理に最適化されています。
-   **MediaPipe Selfie Segmentation**:
    *   **用途**: MediaPipeの一部で、Webカメラの映像から人物のセグメンテーションマスク（人物と背景の分離）をリアルタイムで生成します。本プロジェクトでは、ユーザーの背景をリアルタイムで除去し、ユーザーの姿だけをゲームの3Dステージに合成する（バーチャル背景機能）ために使用されます。これにより、ユーザーはまるでゲームの世界に入り込んだかのような体験を得られます。

## script.js の改善点

以下は、`script.js` の主な改善点です。

- 文字列の正規化（NFC）
    - 歌詞取り込み（TextAlive）で `String(char.text).normalize('NFC').trim()` に統一。
    - フォールバック歌詞生成でもフレーズ・各文字に `NFC` を適用。
    - 表示時 `displayLyric()` でも `NFC` 正規化して描画。
    - 効果: 濁点/結合文字の揺らぎによる不一致や判定漏れを低減。

- 重複テキストの表示と紐付けの堅牢化
    - 鑑賞用歌詞の対応付けキーを「文字列」から「DOM要素（gameBubble）」へ変更。
    - 効果: 同一文字が連続・多発しても、正しく個別にハイライト可能。

- 表示タイミングウィンドウの拡大
    - TextAlive 時の表示判定ウィンドウを 200ms → 500ms に拡大。
    - 効果: 軽いフレーム落ち時の取りこぼしを緩和。

- フォールバック歌詞データ生成の品質向上
    - 生成時に文字列を正規化してから格納。

- ヌル安全性とガードの強化
    - `processLyrics()` で `char.text` をヌル安全に取得（`(char.text ?? '').toString()`）。
    - `displayLyric()` で `null/undefined` を早期 return。

### ユーザーへの影響
- 同じ文字が複数同時に出ても、それぞれ独立してヒット・ハイライトされる。
- 微小なタイミングずれでも歌詞の表示取りこぼしが起きにくい。
- 結合文字や全半角混在などの揺らぎに強くなる。

---

## Hono への移行（最小サーバー導入）

将来的な API/バックエンド拡張を見据え、軽量フレームワーク Hono を用いた最小構成の Node サーバーを追加しました。これにより、以下が可能になります。

- `index.html` や `game.html` を含む静的ファイルの配信（`http://localhost:3000/`）
- シンプルな API エンドポイント（例: `GET /api/health`, `POST /api/echo`）
- CORS/Logger/Powered-By などの基本ミドルウェア

### 追加ファイル

- `package.json`: 依存関係と起動スクリプト（`dev`, `start`）
- `server.js`: Hono のエントリポイント（静的配信と最小 API）

### セットアップと起動

WSL もしくは Node.js 実行環境で以下を実行してください。

```bash
# 依存関係のインストール
npm install

# 開発モード（ファイル変更で自動再起動 / Node v20 以上推奨）
npm run dev

# もしくは通常起動
npm start
```

起動後、ブラウザで以下にアクセスします。

- `http://localhost:3000/` → `index.html` にリダイレクト
- `http://localhost:3000/game.html` → ゲーム画面
- `http://localhost:3000/api/health` → `{ "status": "ok" }`

### 今後の拡張指針（例）

- 認証/ユーザー管理: セッション or JWT（`hono/jwt`）の導入
- スコア保存 API: `POST /api/scores` でスコア送信、`GET /api/scores/:userId` で取得
- 永続化: SQLite/Prisma もしくは D1/Cloudflare KV への移行容易性を確保
- デプロイ: Node ランタイム（VPS/Render/Fly）や Edge（Cloudflare Workers）へのデプロイ

本サーバーは依存を最小限にしており、クライアント側のコード（Three.js, TextAlive, MediaPipe）はそのまま動作します。必要に応じて API への接続コードを `index-scripts.js` または `script.js` から追加していく想定です。

---

## React × Hono への完全移行

プロジェクトを **React + Vite × Hono** 構成に移行しました。システムとデザインは一切変更せず、既存の機能をすべて維持しています。

### 技術構成

#### フロントエンド
- **React 18**: コンポーネントベースのUI構築
- **Vite 5**: 高速な開発サーバーとビルドツール
- **React Router 6**: SPAルーティング
- **Tailwind CSS 3**: ユーティリティファーストCSSフレームワーク

#### バックエンド
- **Hono 4**: 軽量で高速なWebフレームワーク
- **@hono/node-server**: Node.js向けアダプター

#### ゲームシステム（変更なし）
- **GameManager**: 既存のゲームロジックをそのまま使用
- **Three.js**: 3Dステージレンダリング
- **MediaPipe**: 身体・手認識（Pose, Hands, Selfie Segmentation）
- **TextAlive**: 歌詞同期API

### プロジェクト構造

```
star-5/
├── src/
│   ├── components/       # Reactコンポーネント（将来の拡張用）
│   ├── pages/
│   │   ├── IndexPage.jsx # トップページ（曲選択・モード選択）
│   │   └── GamePage.jsx  # ゲームページ
│   ├── data/
│   │   └── songs.js      # 楽曲データ
│   ├── styles/
│   │   ├── index.css     # インデックスページ用CSS
│   │   └── game.css      # ゲームページ用CSS
│   ├── App.jsx           # ルーティング設定
│   ├── main.jsx          # Reactエントリーポイント
│   └── index.css         # グローバルCSS（Tailwind統合）
├── public/
│   └── script.js         # GameManager（既存のゲームロジック）
├── server.js             # Honoサーバー
├── vite.config.js        # Vite設定
├── tailwind.config.js    # Tailwind設定
├── package.json          # 依存関係とスクリプト
└── index.html            # Reactアプリのエントリー
```

### セットアップと実行

#### 1. 依存関係のインストール

```bash
npm install
```

#### 2. 開発環境

ViteとHonoサーバーを同時起動：

```bash
npm run dev
```

- Vite開発サーバー: `http://localhost:5173` （ここにアクセス）
- Honoバックエンド: `http://localhost:3000` （APIエンドポイント）

#### 3. 本番ビルド

```bash
npm run build
npm start
```

`http://localhost:3000` でアプリケーションが利用可能になります。

### 主な変更点

#### アーキテクチャ
- ✅ React + Vite による モダンなフロントエンド開発環境
- ✅ コンポーネントベースのUI構築
- ✅ SPAルーティング（React Router）
- ✅ Tailwind CSSによる効率的なスタイリング
- ✅ HMR（Hot Module Replacement）による高速開発

#### 維持された要素
- ✅ すべてのゲームロジック（GameManager）
- ✅ すべてのデザインとスタイル
- ✅ Three.jsによる3Dステージ
- ✅ MediaPipeによる身体認識
- ✅ TextAliveによる歌詞同期
- ✅ すべてのゲーム機能とエフェクト
- ✅ モバイル対応

### ファイル対応表

| 旧ファイル | 新ファイル | 説明 |
|-----------|-----------|------|
| `index.html` | `src/pages/IndexPage.jsx` | トップページ（React化） |
| `index-scripts.js` | `src/pages/IndexPage.jsx` | ロジックをReactコンポーネントに統合 |
| `index-styles.css` | `src/styles/index.css` | スタイルを維持 |
| `game.html` | `src/pages/GamePage.jsx` | ゲームページ（React化） |
| `game-loader.js` | `src/pages/GamePage.jsx` | ロジックをReactコンポーネントに統合 |
| `styles.css` | `src/styles/game.css` | スタイルを維持 |
| `script.js` | `public/script.js` | GameManagerをそのまま使用 |
| `server.js` | `server.js` | Honoサーバー（SPA対応に更新） |

### 利用可能なコマンド

```bash
# 開発（推奨）
npm run dev              # Vite + Hono同時起動

# 個別起動
npm run server:dev       # Honoサーバーのみ
npm run client:dev       # Viteのみ

# 本番
npm run build            # ビルド（dist/に出力）
npm start                # 本番サーバー起動
npm run preview          # ビルド後のプレビュー
```

### メリット

1. **開発効率の向上**: HMRにより変更が即座に反映
2. **コンポーネント化**: 再利用可能なUIコンポーネント
3. **型安全性**: TypeScriptへの移行が容易
4. **ビルド最適化**: Viteによる高速ビルドとTree-shaking
5. **保守性**: Reactエコシステムによる豊富なツール
6. **拡張性**: APIやデータベースの追加が容易

### 今後の拡張案

- TypeScript化によるる型安全性の向上
- ユーザー認証機能（JWT）
- スコア保存API（Prisma + SQLite/PostgreSQL）
- ランキング機能
- リアルタイムマルチプレイ（WebSocket）
- PWA対応（オフラインプレイ）
- コンポーネントライブラリの導入（Radix UI, shadcn/ui）